# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Stabilize spectral radius of a matrix
#' 
#' @param M Matrix to stabilize
#' @param threshold Maximum allowed spectral radius
#' @return Stabilized matrix
#' @keywords internal
#' @noRd
stabilize_spectral_radius <- function(M, threshold) {
    .Call('_dbn_stabilize_spectral_radius', PACKAGE = 'dbn', M, threshold)
}

#' Safe Cholesky decomposition with regularization
#' 
#' @param L Output lower triangular matrix
#' @param A Input matrix
#' @param reg Regularization parameter
#' @return Success indicator
#' @keywords internal
#' @noRd
safe_cholesky <- function(L, A, reg) {
    .Call('_dbn_safe_cholesky', PACKAGE = 'dbn', L, A, reg)
}

#' Ensure a matrix is positive definite
#' 
#' @param M Input matrix
#' @param min_eigenvalue Minimum eigenvalue threshold
#' @return Positive definite matrix
#' @keywords internal
#' @noRd
ensure_positive_definite <- function(M, min_eigenvalue) {
    .Call('_dbn_ensure_positive_definite', PACKAGE = 'dbn', M, min_eigenvalue)
}

#' Check if VAR process is stationary
#' 
#' @param A Autoregressive coefficient matrix
#' @param B Bilinear coefficient matrix  
#' @param p Number of actors
#' @param q Latent dimension
#' @return Stationarity indicator
#' @keywords internal
#' @noRd
is_stationary <- function(A, B, p, q) {
    .Call('_dbn_is_stationary', PACKAGE = 'dbn', A, B, p, q)
}

#' @keywords internal
#' @noRd
batch_update_Z_ordinal <- function(R_4d, Z_4d, Theta_4d, M, IR, m, p, Tt) {
    .Call('_dbn_batch_update_Z_ordinal', PACKAGE = 'dbn', R_4d, Z_4d, Theta_4d, M, IR, m, p, Tt)
}

#' @keywords internal
#' @noRd
batch_update_Z_ordinal_fast <- function(R_4d, Z_4d, Theta_4d, M, IR, IR_time_indices, m, p, Tt) {
    .Call('_dbn_batch_update_Z_ordinal_fast', PACKAGE = 'dbn', R_4d, Z_4d, Theta_4d, M, IR, IR_time_indices, m, p, Tt)
}

#' @keywords internal
#' @noRd
precompute_time_indices <- function(IR, m, p, Tt) {
    .Call('_dbn_precompute_time_indices', PACKAGE = 'dbn', IR, m, p, Tt)
}

#' @keywords internal
#' @noRd
update_mu_dynamic <- function(Z_4d, Theta_4d, g2, a_g, b_g, m, p, Tt) {
    .Call('_dbn_update_mu_dynamic', PACKAGE = 'dbn', Z_4d, Theta_4d, g2, a_g, b_g, m, p, Tt)
}

#' @keywords internal
#' @noRd
batch_ffbs_all_relations <- function(Z_4d, M, Aarray, Barray, sigma2, m, p, Tt) {
    .Call('_dbn_batch_ffbs_all_relations', PACKAGE = 'dbn', Z_4d, M, Aarray, Barray, sigma2, m, p, Tt)
}

#' @keywords internal
#' @noRd
update_AB_batch_extended <- function(Theta_4d, Aarray_old, Barray_old, sigma2, tauA2, tauB2, ar1, rhoA, rhoB, m, p, Tt) {
    .Call('_dbn_update_AB_batch_extended', PACKAGE = 'dbn', Theta_4d, Aarray_old, Barray_old, sigma2, tauA2, tauB2, ar1, rhoA, rhoB, m, p, Tt)
}

#' @keywords internal
#' @noRd
update_variances_dynamic <- function(Theta_4d, Z_4d, M, Aarray, Barray, a_sig, b_sig, m, p, Tt, is_gaussian = FALSE) {
    .Call('_dbn_update_variances_dynamic', PACKAGE = 'dbn', Theta_4d, Z_4d, M, Aarray, Barray, a_sig, b_sig, m, p, Tt, is_gaussian)
}

#' @keywords internal
#' @noRd
batch_ffbs_all_relations_blocked <- function(Z_4d, M, Aarray, Barray, sigma2, m, p, Tt) {
    .Call('_dbn_batch_ffbs_all_relations_blocked', PACKAGE = 'dbn', Z_4d, M, Aarray, Barray, sigma2, m, p, Tt)
}

#' @keywords internal
#' @noRd
update_AB_batch_large <- function(Theta_4d, Aarray_old, Barray_old, sigma2, tauA2, tauB2, ar1, rhoA, rhoB, m, p, Tt) {
    .Call('_dbn_update_AB_batch_large', PACKAGE = 'dbn', Theta_4d, Aarray_old, Barray_old, sigma2, tauA2, tauB2, ar1, rhoA, rhoB, m, p, Tt)
}

#' @keywords internal
#' @noRd
compute_process_variance_blocked <- function(Theta_4d, Aarray, Barray, m, p, Tt) {
    .Call('_dbn_compute_process_variance_blocked', PACKAGE = 'dbn', Theta_4d, Aarray, Barray, m, p, Tt)
}

#' Fast FFBS for Bilinear Model
#' 
#' @description Efficient FFBS that avoids Kronecker products
#' @param Z Observations (m × m × T)
#' @param mu Baseline mean (m × m)
#' @param A_array Time-varying A matrices (m × m × T)
#' @param B_array Time-varying B matrices (m × m × T)
#' @param sigma2_proc Process variance
#' @param sigma2_obs Observation variance (default 1.0)
#' @return Sampled Theta array (m × m × T)
#' @keywords internal
#' @noRd
ffbs_bilinear <- function(Z, mu, A_array, B_array, sigma2_proc, sigma2_obs = 1.0) {
    .Call('_dbn_ffbs_bilinear', PACKAGE = 'dbn', Z, mu, A_array, B_array, sigma2_proc, sigma2_obs)
}

#' Fast FFBS for Dynamic Linear Model in C++
#' 
#' @description C++ implementation of ffbs_dlm with OpenMP parallelization
#' @param y List of observation vectors (length T)
#' @param Flist List of design matrices (T x (r x p))
#' @param V Observation variance matrix (p x p)
#' @param W State innovation variance matrix (r x r)
#' @param m0 Prior mean vector (r x 1)
#' @param C0 Prior covariance matrix (r x r)
#' @param ar1 Logical: use AR(1) dynamics instead of random walk
#' @param rho AR(1) coefficient (used if ar1=TRUE)
#' @return Matrix of sampled state vectors (r x T)
#' @keywords internal
#' @noRd
ffbs_dlm_cpp <- function(y, Flist, V, W, m0, C0, ar1 = FALSE, rho = 0.0) {
    .Call('_dbn_ffbs_dlm_cpp', PACKAGE = 'dbn', y, Flist, V, W, m0, C0, ar1, rho)
}

#' Batch FFBS for multiple independent DLM problems
#' 
#' @description Parallelized FFBS for updating all rows of A or columns of B simultaneously
#' @param Y_batch Stacked observations (batch_size x T)
#' @param F_batch Design matrices for each problem (batch_size x T x state_dim x obs_dim)
#' @param V_batch Observation variances (can be scalar or vector of length batch_size)
#' @param W State innovation variance (common across batch)
#' @param m0 Prior mean (common)
#' @param C0 Prior covariance (common)
#' @param ar1 Use AR(1) dynamics
#' @param rho AR(1) coefficient
#' @return Matrix of sampled states (batch_size x state_dim x T)
#' @keywords internal
#' @noRd
ffbs_dlm_batch_cpp <- function(Y_batch, F_batch, V_batch, W, m0, C0, ar1 = FALSE, rho = 0.0) {
    .Call('_dbn_ffbs_dlm_batch_cpp', PACKAGE = 'dbn', Y_batch, F_batch, V_batch, W, m0, C0, ar1, rho)
}

#' Structured FFBS for Theta
#' 
#' @description Memory-efficient FFBS that avoids creating n² × n² matrices
#' @param Z Observations (m × m × T array as cube)
#' @param mu Baseline mean (m × m matrix)
#' @param A_array Time-varying A matrices (m × m × T)
#' @param B_array Time-varying B matrices (m × m × T)
#' @param sigma2 Innovation variance (scalar)
#' @return Sampled Theta array (m × m × T)
ffbs_theta_struct_5arg_cpp <- function(Z, mu, A_array, B_array, sigma2) {
    .Call('_dbn_ffbs_theta_struct_5arg_cpp', PACKAGE = 'dbn', Z, mu, A_array, B_array, sigma2)
}

#' @keywords internal
#' @noRd
ffbs_theta_struct_cpp <- function(Z, mu, A_array, B_array, sigma2_proc, sigma2_obs) {
    .Call('_dbn_ffbs_theta_struct_cpp', PACKAGE = 'dbn', Z, mu, A_array, B_array, sigma2_proc, sigma2_obs)
}

compute_gaussian_obs_residuals_cpp <- function(Z, Theta, M) {
    .Call('_dbn_compute_gaussian_obs_residuals_cpp', PACKAGE = 'dbn', Z, Theta, M)
}

compute_gaussian_obs_residuals_4d_cpp <- function(Z_flat, Theta_flat, M_flat, m, p, Tt) {
    .Call('_dbn_compute_gaussian_obs_residuals_4d_cpp', PACKAGE = 'dbn', Z_flat, Theta_flat, M_flat, m, p, Tt)
}

compute_gaussian_obs_residuals_batch_cpp <- function(Z, Theta, M, m, p, Tt) {
    .Call('_dbn_compute_gaussian_obs_residuals_batch_cpp', PACKAGE = 'dbn', Z, Theta, M, m, p, Tt)
}

#' @keywords internal
#' @noRd
forward_hmm <- function(Theta_avg, A_list, B_list, Pi, sigma2, pi0) {
    .Call('_dbn_forward_hmm', PACKAGE = 'dbn', Theta_avg, A_list, B_list, Pi, sigma2, pi0)
}

#' @keywords internal
#' @noRd
forward_hmm_fast <- function(Theta_avg, A_list, B_list, Pi, sigma2, pi0, beam_width = 0L) {
    .Call('_dbn_forward_hmm_fast', PACKAGE = 'dbn', Theta_avg, A_list, B_list, Pi, sigma2, pi0, beam_width)
}

#' @keywords internal
#' @noRd
backward_sample <- function(log_alpha, Pi) {
    .Call('_dbn_backward_sample', PACKAGE = 'dbn', log_alpha, Pi)
}

#' @keywords internal
#' @noRd
backward_sample_fast <- function(log_alpha, Pi) {
    .Call('_dbn_backward_sample_fast', PACKAGE = 'dbn', log_alpha, Pi)
}

#' @keywords internal
#' @noRd
build_regime_arrays <- function(S, A_list, B_list, m, Tt) {
    .Call('_dbn_build_regime_arrays', PACKAGE = 'dbn', S, A_list, B_list, m, Tt)
}

#' @keywords internal
#' @noRd
collect_regime_thetas <- function(Theta_avg, S, regime, m) {
    .Call('_dbn_collect_regime_thetas', PACKAGE = 'dbn', Theta_avg, S, regime, m)
}

#' @keywords internal
#' @noRd
count_transitions <- function(S, R) {
    .Call('_dbn_count_transitions', PACKAGE = 'dbn', S, R)
}

#' @keywords internal
#' @noRd
compute_regime_residuals <- function(A_list, I_m, R, m) {
    .Call('_dbn_compute_regime_residuals', PACKAGE = 'dbn', A_list, I_m, R, m)
}

#' @keywords internal
#' @noRd
init_states_spectral <- function(Y, R, m, p, Tt) {
    .Call('_dbn_init_states_spectral', PACKAGE = 'dbn', Y, R, m, p, Tt)
}

#' Sample from inverse Wishart distribution with stability checks
#' 
#' @param nu Degrees of freedom
#' @param S Scale matrix
#' @return Sample from inverse Wishart distribution
#' @keywords internal
#' @noRd
rinvwishart_stable <- function(nu, S) {
    .Call('_dbn_rinvwishart_stable', PACKAGE = 'dbn', nu, S)
}

#' Check if proposed innovation covariance is valid
#' 
#' @param Sigma_e Proposed innovation covariance
#' @param min_eigenvalue Minimum allowed eigenvalue
#' @param max_condition Maximum allowed condition number
#' @return Validity indicator
#' @keywords internal
#' @noRd
is_valid_innovation_cov <- function(Sigma_e, min_eigenvalue = 1e-6, max_condition = 1e6) {
    .Call('_dbn_is_valid_innovation_cov', PACKAGE = 'dbn', Sigma_e, min_eigenvalue, max_condition)
}

#' Adaptive Metropolis-Hastings update for innovation covariance
#' 
#' @param Sigma_e_current Current innovation covariance
#' @param nu Prior degrees of freedom
#' @param S Prior scale matrix
#' @param X Latent states (p x q x T)
#' @param A Actor transition matrix
#' @param B Latent transition matrix
#' @param adapt_scale Adaptation scale parameter
#' @return List with new covariance and acceptance indicator
#' @keywords internal
#' @noRd
update_innovation_cov_adaptive <- function(Sigma_e_current, nu, S, X, A, B, adapt_scale = 0.1) {
    .Call('_dbn_update_innovation_cov_adaptive', PACKAGE = 'dbn', Sigma_e_current, nu, S, X, A, B, adapt_scale)
}

#' Compute impulse response for constant A,B matrices
#' 
#' @param A Transition matrix A (m x m)
#' @param B Transition matrix B (m x m)
#' @param S Shock matrix (m x m)
#' @param H Number of horizons to compute
#' @return Cube of impulse responses (m x m x H+1)
#' @export
impulse_response_const <- function(A, B, S, H) {
    .Call('_dbn_impulse_response_const', PACKAGE = 'dbn', A, B, S, H)
}

#' Compute impulse response for time-varying A,B matrices
#' 
#' @param Aarray Cube of A matrices over time (m x m x T)
#' @param Barray Cube of B matrices over time (m x m x T)
#' @param S Shock matrix (m x m)
#' @param t0 Time index of shock (0-based)
#' @param H Number of horizons to compute
#' @return Cube of impulse responses (m x m x H+1)
#' @export
impulse_response_dynamic <- function(Aarray, Barray, S, t0, H) {
    .Call('_dbn_impulse_response_dynamic', PACKAGE = 'dbn', Aarray, Barray, S, t0, H)
}

#' @keywords internal
#' @noRd
compute_A_lowrank <- function(U, alpha_t) {
    .Call('_dbn_compute_A_lowrank', PACKAGE = 'dbn', U, alpha_t)
}

#' @keywords internal
#' @noRd
compute_all_A_lowrank <- function(U, alpha, Tt) {
    .Call('_dbn_compute_all_A_lowrank', PACKAGE = 'dbn', U, alpha, Tt)
}

#' @keywords internal
#' @noRd
build_F_alpha_vectorized <- function(U, Theta_prev, B_t, p, Tt) {
    .Call('_dbn_build_F_alpha_vectorized', PACKAGE = 'dbn', U, Theta_prev, B_t, p, Tt)
}

#' @keywords internal
#' @noRd
build_y_alpha_vectorized <- function(Theta_flat, M, m, p, Tt) {
    .Call('_dbn_build_y_alpha_vectorized', PACKAGE = 'dbn', Theta_flat, M, m, p, Tt)
}

#' @keywords internal
#' @noRd
loglik_U <- function(U, alpha, Theta_avg, Barray, sigma2) {
    .Call('_dbn_loglik_U', PACKAGE = 'dbn', U, alpha, Theta_avg, Barray, sigma2)
}

#' @keywords internal
#' @noRd
cayley_transform <- function(U, W, epsilon) {
    .Call('_dbn_cayley_transform', PACKAGE = 'dbn', U, W, epsilon)
}

#' @keywords internal
#' @noRd
generate_skew_proposal <- function(m, norm_cap) {
    .Call('_dbn_generate_skew_proposal', PACKAGE = 'dbn', m, norm_cap)
}

#' @keywords internal
#' @noRd
update_B_lowrank_batch <- function(Theta_flat, U, alpha, sigma2_proc, tau_B2, ar1, rho, m, p, Tt) {
    .Call('_dbn_update_B_lowrank_batch', PACKAGE = 'dbn', Theta_flat, U, alpha, sigma2_proc, tau_B2, ar1, rho, m, p, Tt)
}

#' @keywords internal
#' @noRd
compute_lowrank_residuals <- function(Theta_flat, M, U, alpha, Barray, m, p, Tt) {
    .Call('_dbn_compute_lowrank_residuals', PACKAGE = 'dbn', Theta_flat, M, U, alpha, Barray, m, p, Tt)
}

#' @keywords internal
#' @noRd
compute_sigma2_lowrank_batch <- function(Theta, Aarray, Barray, m, p, Tt) {
    .Call('_dbn_compute_sigma2_lowrank_batch', PACKAGE = 'dbn', Theta, Aarray, Barray, m, p, Tt)
}

#' @keywords internal
#' @noRd
compute_sigma2_simd <- function(Theta, U, alpha, Barray, m, p, Tt, r) {
    .Call('_dbn_compute_sigma2_simd', PACKAGE = 'dbn', Theta, U, alpha, Barray, m, p, Tt, r)
}

#' @keywords internal
#' @noRd
ffbs_theta_all_relations <- function(Z_all, M_all, Aarray, Barray, sigma2_proc, sigma2_obs, m, p, Tt) {
    .Call('_dbn_ffbs_theta_all_relations', PACKAGE = 'dbn', Z_all, M_all, Aarray, Barray, sigma2_proc, sigma2_obs, m, p, Tt)
}

#' @keywords internal
#' @noRd
ffbs_theta_blocked <- function(Z_all, M_all, Aarray, Barray, sigma2_proc, sigma2_obs, m, p, Tt) {
    .Call('_dbn_ffbs_theta_blocked', PACKAGE = 'dbn', Z_all, M_all, Aarray, Barray, sigma2_proc, sigma2_obs, m, p, Tt)
}

#' @keywords internal
#' @noRd
update_alpha_optimized <- function(Theta, U, Barray, sigma2_proc, tau_alpha2, ar1_alpha, rho_alpha, m, p, Tt, r) {
    .Call('_dbn_update_alpha_optimized', PACKAGE = 'dbn', Theta, U, Barray, sigma2_proc, tau_alpha2, ar1_alpha, rho_alpha, m, p, Tt, r)
}

#' @keywords internal
#' @noRd
update_B_blocked <- function(Theta, Aarray, sigma2_proc, tau_B2, ar1_B, rho_B, m, p, Tt) {
    .Call('_dbn_update_B_blocked', PACKAGE = 'dbn', Theta, Aarray, sigma2_proc, tau_B2, ar1_B, rho_B, m, p, Tt)
}

#' @keywords internal
#' @noRd
update_Z_ordinal_global <- function(Z_all, Theta_all, M_all, IR_list, m, p, Tt) {
    invisible(.Call('_dbn_update_Z_ordinal_global', PACKAGE = 'dbn', Z_all, Theta_all, M_all, IR_list, m, p, Tt))
}

#' @keywords internal
#' @noRd
update_B_parallel <- function(Theta, Aarray, sigma2_proc, tau_B2, ar1_B, rho_B, m, p, Tt) {
    .Call('_dbn_update_B_parallel', PACKAGE = 'dbn', Theta, Aarray, sigma2_proc, tau_B2, ar1_B, rho_B, m, p, Tt)
}

#' @keywords internal
#' @noRd
update_alpha_batch <- function(Theta, U, Barray, sigma2_proc, tau_alpha2, ar1_alpha, rho_alpha, m, p, Tt, r) {
    .Call('_dbn_update_alpha_batch', PACKAGE = 'dbn', Theta, U, Barray, sigma2_proc, tau_alpha2, ar1_alpha, rho_alpha, m, p, Tt, r)
}

#' @keywords internal
#' @noRd
update_Z_ordinal_vectorized <- function(Z_all, Theta_all, M_all, IR_list, m, p, Tt) {
    invisible(.Call('_dbn_update_Z_ordinal_vectorized', PACKAGE = 'dbn', Z_all, Theta_all, M_all, IR_list, m, p, Tt))
}

#' Fast parallel Gaussian approximation for ordinal data
#' @keywords internal
#' @noRd
rz_gaussian_approx_cpp <- function(R, Z, EZ, sigma = 1.0) {
    .Call('_dbn_rz_gaussian_approx_cpp', PACKAGE = 'dbn', R, Z, EZ, sigma)
}

#' Validate transition matrix proposals
#' 
#' @param A_prop Proposed actor transition matrix
#' @param B_prop Proposed latent transition matrix
#' @param p Number of actors
#' @param q Latent dimension
#' @param check_stationary Check stationarity condition
#' @return Validity indicator
#' @keywords internal
#' @noRd
validate_transition_proposal <- function(A_prop, B_prop, p, q, check_stationary = TRUE) {
    .Call('_dbn_validate_transition_proposal', PACKAGE = 'dbn', A_prop, B_prop, p, q, check_stationary)
}

#' Adaptive random walk proposal for transition matrices
#' 
#' @param A_current Current actor transition matrix
#' @param B_current Current latent transition matrix
#' @param step_size_A Step size for A
#' @param step_size_B Step size for B
#' @param max_attempts Maximum proposal attempts
#' @return List with proposed matrices and validity indicator
#' @keywords internal
#' @noRd
propose_transition_adaptive <- function(A_current, B_current, step_size_A = 0.1, step_size_B = 0.1, max_attempts = 10L) {
    .Call('_dbn_propose_transition_adaptive', PACKAGE = 'dbn', A_current, B_current, step_size_A, step_size_B, max_attempts)
}

#' Check for edge cases in the data
#' 
#' @param Y Data cube (p x p x T)
#' @return List with edge case indicators
#' @keywords internal
#' @noRd
check_edge_cases <- function(Y) {
    .Call('_dbn_check_edge_cases', PACKAGE = 'dbn', Y)
}

#' Fast rank-likelihood sampler in C++
#' 
#' @description Port of rz_fc() to C++ for ~8-15x speedup on large ordinal networks
#' @param R Observed ranks (vectorized matrix)
#' @param Z Current latent values (vectorized)
#' @param EZ Expected values (vectorized)
#' @param iranks List of indices for each rank level
#' @return Updated Z vector
#' @keywords internal
#' @noRd
rz_fc_cpp <- function(R, Z, EZ, iranks) {
    .Call('_dbn_rz_fc_cpp', PACKAGE = 'dbn', R, Z, EZ, iranks)
}

#' Build rank indices from rank matrix
#' 
#' @description Helper to convert rank matrix to iranks format for C++
#' @param R Rank matrix
#' @return List of indices for each rank
#' @keywords internal
#' @noRd
build_rank_indices <- function(R) {
    .Call('_dbn_build_rank_indices', PACKAGE = 'dbn', R)
}

#' @keywords internal
#' @noRd
rz_fc_matrix <- function(R, Z_current, EZ, iranks) {
    .Call('_dbn_rz_fc_matrix', PACKAGE = 'dbn', R, Z_current, EZ, iranks)
}

#' @keywords internal
#' @noRd
rz_fc_batch <- function(R, Z_current, EZ, IR_list, m, p, Tt) {
    .Call('_dbn_rz_fc_batch', PACKAGE = 'dbn', R, Z_current, EZ, IR_list, m, p, Tt)
}

#' @keywords internal
#' @noRd
precompute_rank_structure <- function(R, m, p, Tt) {
    .Call('_dbn_precompute_rank_structure', PACKAGE = 'dbn', R, m, p, Tt)
}

#' @keywords internal
#' @noRd
bilinear_product_fast <- function(A, Theta, B) {
    .Call('_dbn_bilinear_product_fast', PACKAGE = 'dbn', A, Theta, B)
}

#' @keywords internal
#' @noRd
compute_bilinear_residuals <- function(Theta_flat, Aarray, Barray, m, p, Tt) {
    .Call('_dbn_compute_bilinear_residuals', PACKAGE = 'dbn', Theta_flat, Aarray, Barray, m, p, Tt)
}

#' @keywords internal
#' @noRd
compute_bilinear_residuals_fast <- function(Theta, Aarray, Barray, m, p, Tt) {
    .Call('_dbn_compute_bilinear_residuals_fast', PACKAGE = 'dbn', Theta, Aarray, Barray, m, p, Tt)
}

#' @keywords internal
#' @noRd
compute_observation_residuals <- function(Z_flat, Theta_flat, M, m, p, Tt) {
    .Call('_dbn_compute_observation_residuals', PACKAGE = 'dbn', Z_flat, Theta_flat, M, m, p, Tt)
}

#' @keywords internal
#' @noRd
compute_zscores_batch <- function(Y, means, sds, m, p, Tt) {
    .Call('_dbn_compute_zscores_batch', PACKAGE = 'dbn', Y, means, sds, m, p, Tt)
}

#' @keywords internal
#' @noRd
update_Z_batch <- function(R_flat, Theta_flat, M, IR_list_flat, m, p, Tt) {
    .Call('_dbn_update_Z_batch', PACKAGE = 'dbn', R_flat, Theta_flat, M, IR_list_flat, m, p, Tt)
}

#' @keywords internal
#' @noRd
build_regime_arrays_vectorized <- function(S, A_list, B_list, m, Tt) {
    .Call('_dbn_build_regime_arrays_vectorized', PACKAGE = 'dbn', S, A_list, B_list, m, Tt)
}

#' @keywords internal
#' @noRd
compute_outer_products_batch <- function(U) {
    .Call('_dbn_compute_outer_products_batch', PACKAGE = 'dbn', U)
}

#' @keywords internal
#' @noRd
compute_A_lowrank_batch <- function(outer_prods, alpha, Tt) {
    .Call('_dbn_compute_A_lowrank_batch', PACKAGE = 'dbn', outer_prods, alpha, Tt)
}

#' Reshape 4D array to 3D for C++ processing
#' @description Efficiently reshape Z from m x m x p x Tt to m x m x (p*Tt)
#' @param Z_4d Input 4D array as R array
#' @param m Number of nodes
#' @param p Number of relations
#' @param Tt Number of time points
#' @return 3D cube for C++ processing
#' @keywords internal
#' @noRd
reshape_Z_to_cube <- function(Z_4d, m, p, Tt) {
    .Call('_dbn_reshape_Z_to_cube', PACKAGE = 'dbn', Z_4d, m, p, Tt)
}

#' Compute SSE for diagonal elements efficiently
#' @description Compute sum of squared errors for diagonal elements of B matrices
#' @param B_list List of B matrices
#' @param K Number of matrices
#' @return SSE value
#' @keywords internal
#' @noRd
compute_diagonal_sse <- function(B_list, K) {
    .Call('_dbn_compute_diagonal_sse', PACKAGE = 'dbn', B_list, K)
}

#' Compute sum of squared deviations from identity for A or B arrays
#' @description Efficiently compute sum of squared deviations from the identity matrix 
#'   for each matrix slice of A or B from time t = 2 to Tt
#' @param ABarray 3D array of A or B matrices (m x m x Tt)
#' @param m Number of nodes
#' @param Tt Number of time points
#' @return Sum of squared deviations
#' @keywords internal
#' @noRd
compute_deviation_sum <- function(ABarray, m, Tt) {
    .Call('_dbn_compute_deviation_sum', PACKAGE = 'dbn', ABarray, m, Tt)
}

#' Compute mean M for static model
#' @description Efficiently compute mean of Z across time for each relation
#' @param Z_flat Flattened Z array (m*m x p*Tt)
#' @param m Number of nodes
#' @param p Number of relations
#' @param Tt Number of time points
#' @return M array (m x m x p)
#' @keywords internal
#' @noRd
compute_M_static <- function(Z_flat, m, p, Tt) {
    .Call('_dbn_compute_M_static', PACKAGE = 'dbn', Z_flat, m, p, Tt)
}

#' Compute residual sum of squares for static model
#' @description Compute sum((Z - M)^2) across all times and relations
#' @param Z_4d Original Z array (m x m x p x Tt) as flattened vector
#' @param M Mean array (m x m x p)
#' @param m Number of nodes
#' @param p Number of relations
#' @param Tt Number of time points
#' @return Sum of squared residuals
#' @keywords internal
#' @noRd
compute_rss_static <- function(Z_4d, M, m, p, Tt) {
    .Call('_dbn_compute_rss_static', PACKAGE = 'dbn', Z_4d, M, m, p, Tt)
}

#' Reshape for large networks with parallelization
#' @description Parallel version of reshape_Z_to_cube for large networks
#' @param Z_4d Input 4D array as R array
#' @param m Number of nodes
#' @param p Number of relations
#' @param Tt Number of time points
#' @return 3D cube for C++ processing
#' @keywords internal
#' @noRd
reshape_Z_to_cube_parallel <- function(Z_4d, m, p, Tt) {
    .Call('_dbn_reshape_Z_to_cube_parallel', PACKAGE = 'dbn', Z_4d, m, p, Tt)
}

#' M computation with blocked summation for numerical stability
#' @description Compute mean with blocked summation for large networks
#' @param Z_flat Flattened Z array (m*m x p*Tt)
#' @param m Number of nodes
#' @param p Number of relations
#' @param Tt Number of time points
#' @return M array (m x m x p)
#' @keywords internal
#' @noRd
compute_M_static_blocked <- function(Z_flat, m, p, Tt) {
    .Call('_dbn_compute_M_static_blocked', PACKAGE = 'dbn', Z_flat, m, p, Tt)
}

#' RSS computation with parallel reduction
#' @description Parallel computation of residual sum of squares
#' @param Z_cube Z array as cube (m x m x p*Tt)
#' @param M Mean array (m x m x p)
#' @param m Number of nodes
#' @param p Number of relations
#' @param Tt Number of time points
#' @return Sum of squared residuals
#' @keywords internal
#' @noRd
compute_rss_static_parallel <- function(Z_cube, M, m, p, Tt) {
    .Call('_dbn_compute_rss_static_parallel', PACKAGE = 'dbn', Z_cube, M, m, p, Tt)
}

#' Cache-efficient B update for static model
#' @description B update using tiled matrix operations
#' @param Z_cube Z array as cube
#' @param M Mean array
#' @param s2 Observation variance
#' @param t2 Prior variance
#' @param m Number of nodes
#' @param p Number of relations
#' @param Tt Number of time points
#' @return Updated B matrix
#' @keywords internal
#' @noRd
update_B_static_tiled <- function(Z_cube, M, s2, t2, m, p, Tt) {
    .Call('_dbn_update_B_static_tiled', PACKAGE = 'dbn', Z_cube, M, s2, t2, m, p, Tt)
}

#' @keywords internal
#' @noRd
update_A_batch <- function(Theta_all_1, Theta_all_2, Theta_all_3, Theta_all_4, Aarray, Barray, sigma2, tauA2, ar1 = FALSE, rhoA = 0.0, p = 1L) {
    .Call('_dbn_update_A_batch', PACKAGE = 'dbn', Theta_all_1, Theta_all_2, Theta_all_3, Theta_all_4, Aarray, Barray, sigma2, tauA2, ar1, rhoA, p)
}

#' @keywords internal
#' @noRd
update_B_batch <- function(Theta_all_1, Theta_all_2, Theta_all_3, Theta_all_4, Aarray, Barray, sigma2, tauB2, ar1 = FALSE, rhoB = 0.0, p = 1L) {
    .Call('_dbn_update_B_batch', PACKAGE = 'dbn', Theta_all_1, Theta_all_2, Theta_all_3, Theta_all_4, Aarray, Barray, sigma2, tauB2, ar1, rhoB, p)
}

#' Update A and B matrices for static model (C++ version)
#' 
#' @description Fast C++ implementation of update_AB_static
#' @param Theta_prev Previous Theta values (m x m x n_times)
#' @param Theta_curr Current Theta values (m x m x n_times) 
#' @param B_init Initial B matrix (m x m)
#' @param tau_A2 Prior variance for A
#' @param tau_B2 Prior variance for B
#' @param sigma2 Innovation variance
#' @return List with updated A and B matrices
#' @keywords internal
#' @noRd
update_AB_static_cpp <- function(Theta_prev, Theta_curr, B_init, tau_A2, tau_B2, sigma2) {
    .Call('_dbn_update_AB_static_cpp', PACKAGE = 'dbn', Theta_prev, Theta_curr, B_init, tau_A2, tau_B2, sigma2)
}

#' Build design matrix F for alpha updates (C++ version)
#' 
#' @description Fast C++ implementation of build_F_alpha
#' @param U Orthonormal matrix (m x r)
#' @param Theta_prev Previous Theta values (m x m x T)
#' @param B_array B matrices over time (m x m x T)
#' @param compute_all Compute for all time points at once
#' @return Design matrix F (m^2*T x r) if compute_all=true, else (m^2 x r)
#' @keywords internal
#' @noRd
build_F_alpha_cpp <- function(U, Theta_prev, B_array, compute_all = FALSE) {
    .Call('_dbn_build_F_alpha_cpp', PACKAGE = 'dbn', U, Theta_prev, B_array, compute_all)
}

#' @keywords internal
#' @noRd
compute_XB_tensor <- function(X, B, m, p, n) {
    .Call('_dbn_compute_XB_tensor', PACKAGE = 'dbn', X, B, m, p, n)
}

#' @keywords internal
#' @noRd
update_B_static <- function(Z, M, s2, t2, m, p, n) {
    .Call('_dbn_update_B_static', PACKAGE = 'dbn', Z, M, s2, t2, m, p, n)
}

#' @keywords internal
#' @noRd
broadcast_M_and_compute_EZ <- function(M, s2, m, p, Tt) {
    .Call('_dbn_broadcast_M_and_compute_EZ', PACKAGE = 'dbn', M, s2, m, p, Tt)
}

#' @keywords internal
#' @noRd
compute_s2_update <- function(Z_field, M, m, p, Tt, a_prior, b_prior) {
    .Call('_dbn_compute_s2_update', PACKAGE = 'dbn', Z_field, M, m, p, Tt, a_prior, b_prior)
}

#' @keywords internal
#' @noRd
update_variances_batch <- function(sum_squares, counts, a_priors, b_priors) {
    .Call('_dbn_update_variances_batch', PACKAGE = 'dbn', sum_squares, counts, a_priors, b_priors)
}

#' @keywords internal
#' @noRd
stabilize_matrix <- function(M, min_eig = 1e-6) {
    .Call('_dbn_stabilize_matrix', PACKAGE = 'dbn', M, min_eig)
}

#' @keywords internal
#' @noRd
update_Z_dynamic <- function(R, Z_current, Theta, M, IR, m, p, Tt) {
    .Call('_dbn_update_Z_dynamic', PACKAGE = 'dbn', R, Z_current, Theta, M, IR, m, p, Tt)
}

#' @keywords internal
#' @noRd
precompute_products <- function(Aarray, Barray, m, Tt) {
    .Call('_dbn_precompute_products', PACKAGE = 'dbn', Aarray, Barray, m, Tt)
}

#' @keywords internal
#' @noRd
compute_residual_sum_squares <- function(Z_field, M, p) {
    .Call('_dbn_compute_residual_sum_squares', PACKAGE = 'dbn', Z_field, M, p)
}

#' @keywords internal
#' @noRd
compute_innovation_variance <- function(X_curr, X_prev, ar1 = FALSE, rho = 0.0) {
    .Call('_dbn_compute_innovation_variance', PACKAGE = 'dbn', X_curr, X_prev, ar1, rho)
}

#' @keywords internal
#' @noRd
compute_M_update <- function(Z_field, g2, m, p) {
    .Call('_dbn_compute_M_update', PACKAGE = 'dbn', Z_field, g2, m, p)
}

#' @keywords internal
#' @noRd
compute_AB_innovations <- function(Aarray, Barray, ar1 = FALSE, rhoA = 0.0, rhoB = 0.0) {
    .Call('_dbn_compute_AB_innovations', PACKAGE = 'dbn', Aarray, Barray, ar1, rhoA, rhoB)
}

